

## 海量数据处理

这部分内容是海量数据处理的问题。所谓海量：

时间上：无法在较短时间内迅速解决。可以设计巧妙的算法搭配合适的数据结构解决
空间上：数据量太大，无法一次全部装入内存；针对方法是大而化小，分而治之。将规模大划分为规模小的问题，各个击破

海量处理问题常用的分析解决问题的思路是：

1. 分而治之/Hash映射 + hash统计/trie树/红黑树/二叉搜索树 + 堆排序/快速排序/归并排序
2. 双层桶划分
3. Bloom filter 、Bitmap
4. Trie树/数据库/倒排索引
5. 外排序
6. 分布处理之 Hadoop/Mapreduce



### top-1问题 —— 海量日志提取访问最多的IP

海量日志处理，提取某日访问百度次数最多的那个IP

#### 估算

我们先来估算下，一个IP可以用32bit表示，总共可以表示 2^32 = 42亿九千万个IP 。假设一个IP一天内访问百度的次数不超过40亿次，可以用unsigned 的数表示。用数组统计出每个IP地址出现的最大次数，就可以得到访问次数最大的IP地址

unsigned count[N],这个N=2^32=4G个IP地址 sizeof(count) = 4*N = 16G内存，远超过32位机器所支持的4G内存大小。因此不能直接创建这个数组。


#### 分治法/文件映射

假设运行使用的内存是512MB, 512M/4 = 128M个IP地址（一个IP地址32位，占4个字节），也就是内存中可以同时放 128M个内存地址；另一个角度理解就是，`512M内存可以统计128M个不同的IP地址的访问次数`，哪怕切割的小文件中的IP总数大于128M

4G/128M = 32，也就是把IP地址划分成 32 个不同的区间段，addr[1-xx],addr[xx-xx]..分别计算每个区间中访问次数最大的IP，然后再比较32个区间段中的最大次数，就可以得到所有IP的做大值了。

一个区间段的IP地址个数任然可能撑破128M个，从而撑爆内存

具体实施：

把大文件映射到小文件，有2种方式：

1. 取模映射 。 IP%32 映射到32个小文件，把model相同的IP保存到同一个文件
2. 位运算映射。把IP的前5为作为作为区间编号，即 IP>>27 结果就是[0,31]，把相同区间的IP保存到同一个文件

上面的映射中，`都不会出现同一个IP映射到不同小文件的情况`


#### 统计每个小文件中的最大值

现在文件不同的IP数量达到内存承受的范围了，可以统计小文件中的IP次数了，使用常规的 hash_map(IP,count) 来 统计了。可以分块读取来减少磁盘IO

 
#### 排序 堆排序/快速排序/归并排序


#### 代码示例

```

```


#### 类似问题

1. 怎么在海量数据中找出重复次数最多的一个？
2. 服务器内存1G，有一个2G的文件，里面每行存着一个QQ号（5-10位数），怎么最快找出出现过最多次的QQ号。（10位数可以表示(不到)10亿个QQ号）



#### top-K 找出最大的k个数

类似的题目类型有：

100w个数中找出最大的100个数。
寻找热门查询，300万个查询字符串中统计最热门的10个查询。
有一个文件中保存了2亿个整数，每个整数都以' '分隔。求最大的100万个整数之和。
有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用5分钟时间，找出重复出现最多的前10条。
一个文件中包含了1亿个随机整数，如何快速的找到最大(小)的100万个数字?（时间复杂度：O（n lg k）） 
有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。


分析： hashmap统计+二叉堆


方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。

方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。

方 案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要 大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。



这里给个最简单hash函数，`字符串到int类型的哈希`   
```  
int hash_function(const char *p)    
{    
    int value = 0;    
    while (*p != '\0')    
    {    
        value = value * 31 + *p++;    
        if (value > HASHLEN)    
            value = value % HASHLEN;    
    }    
    return value;    
}  
```

这个hash函数要确保 不同的字符串 hash出不同的一个 整数。


类似的题目还有：

#####  有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。

方案1：顺序读文件中，对于每个词x，取clip_image014，然后按照该值存到5000个小文件（记为clip_image016） 中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，知道分解得到的小文件的大小都不超过1M。对 每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点 的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。



##### 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。

方 案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个 词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一 个。


##### 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。

方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。




##### 寻找热门查询：

搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较 高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询 串，要求使用的内存不能超过1G。

(1) 请描述你解决这个问题的思路；

(2) 请给出主要的处理流程，算法，以及算法的复杂度。

方案1：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。




#### 分布式中的top-K

海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。


方案1：

s 在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。比如求TOP10大，我们首先取前 10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元 素就是TOP10大。

s 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。




#### 统计指定时间段内ip访问量


假设某个网站每天有超过10亿次的页面访问量，出于安全考虑，网站会记录访问客户端访问的ip地址和对应的时间，如果现在已经记录了1000亿条数据，想统计一个指定时间段内的区域ip地址访问量，那么这些数据应该按照何种方式来组织，才能尽快满足上面的统计需求呢，
设计完方案后，并指出该方案的优缺点，比如在什么情况下，可能会非常慢？

参考答案：用B+树来组织，非叶子节点存储（某个时间点，页面访问量），叶子节点是访问的IP地址。这个方案的优点是查询某个时间段内的IP访问量很快，但是要统计某个IP的访问次数或是上次访问时间就不得不遍历整个树的叶子节点。或者可以建立二级索引，分别是时间和地点来建立索引。

 



#### 文件中的内容排序并去重复


1) 如果文件太大，就分片
2） 这里的问题是去除重复，分片后，小文件合并又是个麻烦事。
3） 直接hash统计，假设不重复的url最多300万,采用hash存储需要的空间 300万*4


linux中的几个命令：
```
sort 将文件内容排序
uniq 检查和删除文件内容中重复出现的行列
comm 比较2个已经排序的文件
```

对于较大文件 G级别的文件
split -b 把大文件分割成小文件
然后用 sort 分别排序
sort -m 合并结果
然后在 uniq 命令去重


类似的题目有：
大量的URL字符串，如何从中去除重复的，优化时间空间复杂度
对2亿条手机号码删除重复记录



#### 在O(n lg k)时间内，将k个排序表合并成一个排序表，n为所有有序表中元素个数

【解析】取前100 万个整数，构造成了一棵数组方式存储的具有小顶堆，然后接着依次取下一个整数，如果它大于最小元素亦即堆顶元素，则将其赋予堆顶元素，然后用Heapify调整整个堆，如此下去，则最后留在堆中的100万个整数即为所求 100万个数字。该方法可大大节约内存。



#### 搜索中的智能提示（如 "中国" ,"zhongguo",考虑拼音）

把2万个汉字排序，弄成一个超长的字符串

用Int16索引汉字的所有拼音

Int64 建立汉字和拼音的关联--汉字有多音字，需要把多个拼音pack到一个Int64，位操作搞定

二分+位移unpack，直接做到汉字到拼音的检索




#### 找出文件中相反的串对

一个文件，内含一千万行字符串，每个字符串在1K以内，要求找出所有相反的串对，如abc和cba。

分析：
文件大小上限是：1000万*1K ~ 10GB。不可能内存操作

1) 设计hash函数 使得相反串得到相同的hash值 ？





 
#### 求出这个文件里的整数里不包含的一个整数

一个文件中有40亿个整数，每个整数为四个字节，内存为1GB，写出一个算法：求出这个文件里的整数里不包含的一个整数

40亿*4 = 15GB, 
4个字节表示的整数，总共有2^32个可能
使用`位图法`来统计：
1）分配 2^29 X 2^3 = 512MB 的内存空间，每一个bit代表一个整数，全部初始化为0；
buffer[512x1024x1024]

2) 读入一个数，把对应的bit位置为1.
如读入的是 312 , 将对应的bit置为1：312/8=39 312%8=0 ，写入位置是 第40个字节，0号bit

3) 处理完40亿数据后，遍历500M内存，找到一个bit为0的位
for(unsigned int i=0;i<0xffffffff,i++){
   if(!buffer){//为0则不包括这个整数
        
   }
}


`位图法` 适用于大规模数据，通常用来判断某个数据存不存在

写入指定位:
bytepos = i/8 = i>>3
bitpos = i%8 = i & 0x1F

置为1：arr[bytepos] |= (1 << bitpos)
置为0：arr[bytepos] &= !(1<< bitpos)

void setbit(int *bitmap,int i){
    bitmap[i>>3] |= (1 << (i&0x1F) );
}

读指定位:
getbit(int *bitmap,int i){
    return bitmap[i>>3] & ( 1 << (i&0x1F) );
}





#### 对文件里的整数排序

假设一个文件中有9亿条不重复的9位整数，现在要求对这个文件进行排序。

9位整数做多可表示10亿条不重复整数(无符号数)
9亿*4=3.4GB内存，一次读入内存是不可能了。

思路一： 位图法排序
1） 计算需要内存： 9亿/8/1024/1024 < 120MB ,全部初始化为0
2） 读取文件中的数据，将数据对应的bit位置1
`分段读取`
3） 遍历整个bit，将bit为1的依次存入文件

思路二：?




#### {url,size} 查询子串并按size排序

给出一个文件，里面包含两个字段{url、size}，即url为网址，size为对应网址访问的次数；

要求：

问题1、利用Linux Shell命令或自己设计算法，
查询出url字符串中包含“baidu”子字符串对应的size字段值；

问题2、根据问题1的查询结果，对其按照size由大到小的排列。
（说明：url数据量很大，100亿级以上）
 




#### 找出文件中的中位数

在一个文件中有 10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。只写出思路即可。



#### 找出重复登陆的QQ号

腾讯服务器每秒有2w个QQ号同时上线，找出5min内重新登入的qq号并打印出来。



#### 海量节点树中寻找共同祖先

有一个一亿节点的树，现在已知两个点，找这两个点的共同的祖先。



#### 设计流量统计系统

某服务器流量统计器，每天有1000亿的访问记录数据，包括时间、url、ip。设计系统实现记录数据的保存、管理、查询。要求能实现一下功能：

（1）计算在某一时间段（精确到分）时间内的，某url的所有访问量。
（2）计算在某一时间段（精确到分）时间内的，某ip的所有访问量。

 

#### a,b文件中共同的记录

1. 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

方案1：可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

s 遍历文件a，对每个url求取clip_image002，然后根据所取得的值将url分别存储到1000个小文件（记为clip_image004）中。这样每个小文件的大约为300M。

s 遍历文件b，采取和a相同的方式将url分别存储到1000各小文件（记为clip_image006）。这样处理后，所有可能相同的url都在对应的小文件（clip_image008）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。

s 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

方 案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。



2. 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。

方案1：

s 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为clip_image010）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。

s 找一台内存在2G左右的机器，依次对clip_image010[1]用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为clip_image012）。

s 对clip_image012[1]这10个文件进行归并排序（内排序与外排序相结合）。

方案2：

一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。

方案3：

与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。






#### 找出不重复的整数(QQ号)

在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。

方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存clip_image020内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

方案2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。




#### 字符串去重

1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？

方案1：这题用trie树比较合适，hash_map也应该能行。




#### 如何随机选取1000个关键字

给定一个数据流，其中包含无穷尽的搜索关键字（比如，人们在谷歌搜索时不断输入的关键字）。如何才能从这个无穷尽的流中随机的选取1000个关键字？



类似的题目还有：

有一个很大很大的输入流，大到没有存储器可以将其存储下来，而且只输入一次，如何从这个输入流中随机取得m个记录



#### 最大间隙问题

给定n个实数clip_image042，求着n个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。

方案1：最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：

s 找到n个数据中最大和最小数据max和min。

s 用n-2个点等分区间[min, max]，即将[min, max]等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为clip_image044，且桶clip_image046的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为：clip_image048。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为clip_image050），且认为将min放入第一个桶，将max放入第n-1个桶。

s 将n个数放入n-1个桶中：将每个元素clip_image052分配到某个桶（编号为index），其中clip_image054，并求出分到每个桶的最大最小数据。

s 最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙 不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶 i的上界和桶j的下界之间产生clip_image056。一遍扫描即可完成。





####  将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如：clip_image058。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出clip_image060。

(1) 请描述你解决这个问题的思路；

(2) 给出主要的处理流程，算法，以及算法的复杂度；

(3) 请描述可能的改进。

方案1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于clip_image062， 首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把 它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以 记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。




#### 最大子序列与最大子矩阵问题

数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。

方案1：这个问题可以动态规划的思想解决。设clip_image064表示以第i个元素clip_image066结尾的最大子序列，那么显然clip_image068。基于这一点可以很快用代码实现。

最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。

方案1：可以采用与最大子序列类似的思想来解决。如果我们确定了选择第i列和第j列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。代码详见我的博客。




#### 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到clip_image022个数中的中数？

方案1：先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有clip_image018[1]个）。我们把0到clip_image024的整数划分为N个范围段，每个段包含clip_image026个整数。比如，第一个段位0到clip_image028，第二段为clip_image026[1]到clip_image030，…，第N个段为clip_image032到clip_image024[1]。 然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。 注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于clip_image034，而在第k-1个机器上的累加数小于clip_image034[1]，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第clip_image036位。然后我们对第k个机器的数排序，并找出第clip_image036[1]个数，即为所求的中位数。复杂度是clip_image038的。

方案2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第clip_image034[2]个便是所求。复杂度是clip_image040的。



 

















